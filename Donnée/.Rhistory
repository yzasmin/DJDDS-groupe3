pgeom(5,O.2)
pgeom(5,prob=O.2)
pgeom(5,prob=1/5)
pgeom(5,prob=0.2)
pgeom(4,prob=0.2)
pgeom(4,prob=0.3)
dgeom(4,prob=0.3)
x0=rep(1,10)
x1=c(2,2,0,0,0,1,0,0,2,0)
x2=c(17,20,21,18,31,34,20,17,48,16)
x3=c(52,56,27,34,29,38,38,25,53,36)
X=cbind(x0,x1,x2,x3)
y=c(21,26,37,40,35,37,35,26,42,38)
Ainv=solve(t(X)%*%X)
betac=Ainv%*%t(X)%*%y
betac
yc=X%*%betac
epsilonc=y-yc
sigma2c=sum(epsilonc^2)/(10-1-3)
SCR=sum(epsilonc^2)
SCT=sum((y-mean(y))^2)
R2=1-SCR/SCT
R2tilde= 1-((9*SCR)/(6*SCT))
SCT
R2
t(X)
t(X)%*%X
t(X)
betax
betac
Ainv
yc
sigma2c
epsilonc
clear
data(iris)
data(iris)
library(ggvis)
library(class)   # required for knn
library(caret)
data(iris)
library(ggvis)
library(class)   # required for knn
library(caret)
data(iris)
pairs(iris[1:4], main = "Données Iris -- 3 espèces", pch = 21, bg = c("blue","orange", "green3")[iris$Species], lower.panel=NULL, labels=c("Sepal.Length","Sepal.Width","Petal.Length","Petal.Width"), font.labels=0.5, cex.labels=2)
legend(0.08, 0.43, as.vector(unique(iris$Species)),  fill=c("blue","orange", "green3"))
pairs(iris[1:4], main = "Données Iris -- 3 espèces", pch = 21, bg = c("blue","orange", "green3")[iris$Species], lower.panel=NULL, labels=c("Sepal.Length","Sepal.Width","Petal.Length","Petal.Width"), font.labels=0.5, cex.labels=2)
legend(0.08, 0.43, as.vector(unique(iris$Species)),  fill=c("blue","orange", "green3"))
pairs(iris[1:4], main = "Données Iris -- 3 espèces", pch = 21, bg = c("blue","orange", "green3")[iris$Species], lower.panel=NULL, labels=c("Sepal.Length","Sepal.Width","Petal.Length","Petal.Width"), font.labels=0.5, cex.labels=2)
legend(0.08, 0.43, as.vector(unique(iris$Species)),  fill=c("blue","orange", "green3"))
pairs(iris[1:4], main = "Données Iris -- 3 espèces", pch = 21, bg = c("blue","orange", "green3")[iris$Species], lower.panel=NULL, labels=c("Sepal.Length","Sepal.Width","Petal.Length","Petal.Width"), font.labels=0.5, cex.labels=2)
legend(0.08, 0.43, as.vector(unique(iris$Species)),  fill=c("blue","orange", "green3"))
head(iris) #affiche les premières lignes du jeu de données
str(iris) #Quelles sont les différentes variables ?
summary(iris) #résumé plus complet des données
dim(iris)
table(iris)
table(iris$Species)
x <- iris$Species
table(x)
prop.table(x)
prop.table?
help("prop.table")
help("prop.table")
x <- iris$Species
T_iris <- table(x)
T_iris
prop.table(T_iris)
x <- iris$Species
T_iris <- table(x)
T_iris
round(prop.table(T_iris))
x <- iris$Species
T_iris <- table(x)
T_iris
round(prop.table(T_iris)*100)
x <- iris$Species
T_iris <- table(x)
T_iris
round(prop.table(T_iris)*100, digits = 1)
help(apply)
type(iris)
iris
stdize <- function(x) {
return((x - min(x)) / (max(x) - min(x)))
}
iris[,1:4] <- as.data.frame(apply(iris[,1:4],2, stdize))
summary(iris)
x <- iris[, 1:4]
y <- iris$Species
knn.pred <- knn(x,x, cl = y, k = e)
x <- iris[, 1:4]
y <- iris$Species
knn.pred <- knn(x,x, cl = y, k = 1)
pred_list[[e]] <- knn.pred
x <- iris[, 1:4]
y <- iris$Species
knn.pred <- knn(x,x, cl = y, k = 1)
print(mean(y!=knn.pred))
accuracy_values[e] <- mean(y!=knn.pred)
x <- iris[, 1:4]
y <- iris$Species
knn.pred <- knn(x,x, cl = y, k = 1)
print(mean(y!=knn.pred))
x <- iris[, 1:4]
y <- iris$Species
knn.pred <- knn(x,x, cl = y, k = 1)
print(mean(y!=knn.pred))
knn.pred
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
knn.pred
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
knn.pred
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
knn.pred
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
knn.pred
Npop<-nrow(iris) #nombre d'individus total
taille.test<-Npop/3 #on décide que la taille du jeu de test représentera 1/3 de la taille du jeu de données total
K<-1
#création du découpage apprentissage-test ; on sélectionne au hasard les indices des individus qui seront dans le jeu de test et d'apprentissage
test.ind<-sample(1:Npop,taille.test)
appr.ind<-setdiff(1:Npop,test.ind)
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
knn.pred
#Matrice de confusion
table(iris[test.ind,5], knn.pred)
#Taux d'erreur
mean(iris[test.ind,5] != knn.pred)
# Accuracy
mean(iris[test.ind,5] == knn.pred) * 100
# Accuracy
mean(iris[test.ind,5] == knn.pred) * 100
# On peut aussi calculer l'accuracy en regardant 1-taux d'erreur
(1-mean(iris[test.ind,5]!=knn.pred))*100
K<-Npop-taille.test
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=K)
#matrice de confusion
table(iris[test.ind,5],knn.pred)
#taux d'erreur
mean(iris[test.ind,5]!=knn.pred)
taille.appr=Npop-taille.test
accuracy=numeric(taille.appr) #pour chaque valeur de K, on va stocker l'accuracy du modèle correspondant
#on fait une boucle sur les valeurs possibles de K (de 1 à taille.appr)
for(i in 1:taille.appr){
#réalisation de la prédiction
knn.pred<-knn(iris[appr.ind,-5],iris[test.ind,-5],iris[appr.ind,5],k=i)
#Accuracy
accuracy[i]=(1-mean(iris[test.ind,5]!=knn.pred))*100
}
#On plot l'accuracy par rapport à la valeur de K
plot(accuracy, type="b", col="dodgerblue", cex=1, pch=20,
xlab="K, nombre de voisins", ylab="Accuracy",
main="Accuracy vs Nombre de voisins")
# Lignes horizontale identifiant les valeurs de K pour lesquelles on a la meilleure accuracy
abline(v=which(accuracy==max(accuracy)), col="darkorange", lwd=1.5)
#Ligne verticale indiquant quelle est la valeur maximale d'accuracy observée
abline(h=max(accuracy), col="grey", lty=2)
#Ligne verticale indiquant quelle est la valeur minimale d'accuracy observée
abline(h=min(accuracy), col="grey", lty=2)
#install.packages("mlbench")
#install.packages("caret")
library(mlbench)
library(class)  # pour knn
library(caret)  # pour diviser les données
library(ggplot2)
data("PimaIndiansDiabetes", package = "mlbench")
head(PimaIndiansDiabetes)
ggplot(data=PimaIndiansDiabetes,aes(x = glucose, y=pressure, colour=diabetes))+
geom_point()
dataset <- PimaIndiansDiabetes
set.seed(10)
Index <- createDataPartition(dataset$diabetes, p = 0.7, list = FALSE)
data <- dataset[Index,]
x <- data[, -9]
y <- data$diabetes
knn.pred <- knn(x,x, cl = y, k = 5)
knn.pred
mean(y!=knn.pred)
set.seed(10)
Index <- createDataPartition(dataset$diabetes, p = 0.7, list = FALSE)
data <- dataset[Index,]
pred_list <- list()
accuracy_values <- numeric(100)
for (e in 1:100){
x <- data[, -9]
y <- data$diabetes
knn.pred <- knn(x,x, cl = y, k = e)
pred_list[[e]] <- knn.pred
print(mean(y!=knn.pred))
accuracy_values[e] <- mean(y!=knn.pred)
}
results_df <- data.frame(
K = 1:100,
Accuracy = accuracy_values
)
# Tracer la courbe de l'exactitude en fonction de K
ggplot(results_df, aes(x = K, y = Accuracy)) +
geom_line(color = "blue") +
geom_point(color = "red") +
labs(title = "Exactitude du KNN en fonction de K",
x = "Valeur de K",
y = "Exactitude") +
theme_minimal()
best_k <- which.min(accuracy_values)
print(best_k)
data.sup <- dataset[-Index,]
x.supp <- data.sup[, -9]
y.supp <- data.sup$diabetes
knn.pred <- knn(x,x.supp, cl = y, k = 3)
knn.pred
mean(y.supp!=knn.pred)
#installer le package readxl si nécessaire
install.packages("readxl")
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
#installer le package readxl si nécessaire
install.packages("readxl")
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
terre_data <- read_excel("analyse_de_terre.xlsx")
cleaned_table <- read_excel("DataVdt_table.xlsx")
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
#installer le package readxl si nécessaire
install.packages("readxl")
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
# Obtenir le répertoire de travail actuel
current_directory <- getwd()
# Afficher le répertoire de travail
print(current_directory)
#Charger les bibliothèques nécessaires
library(readxl)
#installer le package readxl si nécessaire
install.packages("readxl")
# Obtenir le répertoire de travail actuel
current_directory <- getwd()
# Afficher le répertoire de travail
print(current_directory)
setwd("/Users/justinemanuel/Documents/GitHub/DJDDS-groupe3/Donnée)"
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
terre_data <- read_excel("analyse_de_terre.xlsx")
getwd()
setwd("/Users/justinemanuel/Documents/GitHub/DJDDS-groupe3/Donnée)"
setwd("/Users/justinemanuel/Documents/GitHub/DJDDS-groupe3/Donnée")
setwd("/Users/justinemanuel/Documents/GitHub/DJDDS-groupe3/Donnée")
Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
terre_data <- read_excel("analyse_de_terre.xlsx")
cleaned_table <- read_excel("DataVdt_table.xlsx")
parcel_table <- read_excel("TableauxdonnéesParcelle.xlsx")
#Harmoniser les noms des colonnes pour identifier les parcelles
#Dans biomasse_data, la colonne des parcelles est 'code echantillon'
biomasse_data <- biomasse_data %>% rename(Parcelle = code echantillon)
#Dans terre_data, la colonne des parcelles est 'Réf échantillon'
terre_data <- terre_data %>% rename(Parcelle = Réf échantillon)
#Harmoniser les noms des colonnes pour identifier les parcelles
#Dans biomasse_data, la colonne des parcelles est 'code echantillon'
biomasse_data <- biomasse_data %>% rename(Parcelle = 'code echantillon')
#Dans terre_data, la colonne des parcelles est 'Réf échantillon'
terre_data <- terre_data %>% rename(Parcelle = 'Réf échantillon')
cleaned_table <- cleaned_data %>% rename(Parcelle = 'code')
cleaned_table <- cleaned_table %>% rename(Parcelle = 'code')
# Obtenir le répertoire de travail actuel
current_directory <- getwd()
# Afficher le répertoire de travail
print(current_directory)
setwd("/Users/justinemanuel/Documents/GitHub/DJDDS-groupe3/Donnée")
#Charger les bibliothèques nécessaires
library(readxl)
library(dplyr)
#Charger les fichiers Excel
biomasse_data <- read_excel("BiomasseMoleculaireMicrobienne.xlsx")
terre_data <- read_excel("analyse_de_terre.xlsx")
cleaned_table <- read_excel("DataVdt_table.xlsx")
cleaned_table <- read_excel("DataVdt.xlsx")
parcel_table <- read_excel("TableauxdonnéesParcelle.xlsx")
#Harmoniser les noms des colonnes pour identifier les parcelles
#Dans biomasse_data, la colonne des parcelles est 'code echantillon'
biomasse_data <- biomasse_data %>% rename(Parcelle = 'code echantillon')
#Dans terre_data, la colonne des parcelles est 'Réf échantillon'
terre_data <- terre_data %>% rename(Parcelle = 'Réf échantillon')
cleaned_table <- cleaned_table %>% rename(Parcelle = 'code')
View(terre_data)
View(terre_data)
View(parcel_table)
View(parcel_table)
View(cleaned_table)
View(cleaned_table)
cleaned_table <- read_excel("DataVdt.xlsx")
View(cleaned_table)
View(cleaned_table)
cleaned_table <- read_excel("DataVdt.xlsx")
#Fusionner biomasse_data et terre_data sur la colonne 'Parcelle'
merged_data <- merge(biomasse_data, terre_data, by = "Parcelle")
#Ajouter cleaned_table également sur la colonne 'Parcelle'
merged_data <- merge(merged_data, parcel_table, by = "Parcelle")
#Vérifier le résultat
head(merged_data)
write.csv(merged_data, "merged_data.csv", row.names = FALSE)
install.packages("dplyr")
install.packages("ggplot2")
# Charger les bibliothèques
library(dplyr)
library(ggplot2)
summary(merged_data)
correlation_matrix <- cor(merged_data)
View(merged_data)
ggplot(merged_data, aes(x = Moy E1_E2, y = Surface)) +
ggplot(merged_data, aes(x = "Moy E1_E2", y = "Surface")) +
geom_point()
library(ggplot2)
# Créer un nuage de points
ggplot(merged_data, aes(x = `Moy E1_E2`, y = Surface)) +
geom_point() +
labs(title = "Nuage de Points entre Moy E1_E2 et Surface",
x = "Moy E1_E2",
y = "Surface") +
theme_minimal()
# Créer un nuage de points
ggplot(merged_data, aes(x = `Moy E1_E2`, y = Surface)) +
geom_point() +
labs(title = "Nuage de Points entre BMM et Surface",
x = "Moy E1_E2",
y = "Surface") +
theme_minimal()
# Créer un nuage de points
ggplot(merged_data, aes(x = `Moy E1_E2`, y = Surface)) +
geom_point() +
labs(title = "Nuage de Points entre BMM et Surface",
x = "BMM",
y = "Surface") +
theme_minimal()
